
#pragma once

#include "ast/top_node.hpp"
#include "utility/semantic_version.hpp"
#include "utility/generator.hpp"
#include "error/error_list.hpp"
#include "tokenizer/line_table.hpp"
#include <gsl/gsl>
#include <expected>
#include <system_error>
#include <filesystem>
#include <memory>
#include <variant>
#include <compare>
#include <mutex>

namespace hk {

class repository;

class source {
public:
    enum class kind_type { unknown, module, library, program };

    using source_type = std::variant<std::filesystem::path, std::pair<fqname, size_t>>;
    using name_type = std::variant<std::monostate, fqname, std::string, std::string>;

    /** Create a source from a file in the repository.
     *
     * @param path The cannonical path to the source-code file.
     */
    source(repository& parent, std::filesystem::path path);

    /** Create a source that was generated by another module in the repository.
     *
     * @param generating_module The module that generated the source code.
     * @param lineno The lineno where the source code was generated.
     */
    source(repository& parent, fqname generating_module, size_t lineno);

    /** Lock the source.
     * 
     * Used for parralel compilation of sources.
     */
    void lock() const
    {
        return _mutex.lock();
    }

    /** Unlock the source.
     * 
     * Used for parralel compilation of sources.
     */
    void unlock() const
    {
        return _mutex.unlock();
    }

    /** The code was generated by another module.
     */
    [[nodiscard]] bool is_generated() const noexcept;

    /** The source file is enabled.
     *
     */
    [[nodiscard]] bool enabled() const
    {
        if (_prologue_ast != nullptr) {
            return _prologue_ast->enabled();
        }
        if (_ast != nullptr) {
            return _ast->enabled();
        }

        // Compilation failed.
        return false;
    }

    /** Is this module used by this project.
     * 
     *  * Is the module imported by programs or libraries that are compiled.
     *  * Is this source a program or library to be compiled.
     */
    [[nodiscard]] bool used() const noexcept
    {
        return _used;
    }

    void set_used(bool used) noexcept
    {
        _used = used;
    }

    /** The kind of source this is.
     *
     *  - unknown: The prologue has not been scanned or there was an error.
     *  - module: The source is a module file.
     *  - program: The source code will generate an executable.
     *  - library: The source code will generate an FFI-library.
     */
    [[nodiscard]] kind_type kind() const noexcept;

    [[nodiscard]] name_type const& name() const noexcept
    {
        return _name;
    }

    [[nodiscard]] source_type const& source_filename() const noexcept
    {
        return _source_filename;
    }

    [[nodiscard]] fqname const& module_name() const
    {
        assert(kind() == kind_type::module);
        return std::get<fqname>(name());
    }

    [[nodiscard]] semantic_version version() const
    {
        return _version;
    }

    [[nodiscard]] repository& repository() const noexcept
    {
        assert(_parent != nullptr);
        return *_parent;
    }

    /** Path to the source code.
     *
     * @return Path to the source code, or empty if the code was generated.
     */
    [[nodiscard]] std::filesystem::path const& path() const;

    /** Parse the prologue.
     *
     * This function will optionally load a fresh copy of source-code from
     * disk, then read the prologue.
     *
     * @return If prologue of the source file was modified, or an error.
     */
    std::expected<bool, std::error_code> parse_prologue();

    [[nodiscard]] error_list& errors() noexcept
    {
        return _errors;
    }

    [[nodiscard]] line_table const& lines() const noexcept
    {
        return _lines;
    }

    [[nodiscard]] ast::top_node& top() const
    {
        if (_ast != nullptr) {
            return *_ast;
        }

        assert(_prologue_ast != nullptr);
        return *_prologue_ast;
    }

    [[nodiscard]] ast::top_declaration_node& file_declaration() const;

    /** Remote Repository
     *
     * @pre `evaluate(datum_namespace const&)` must be called first.
     */
    [[nodiscard]] generator<ast::import_repository_declaration_node*> remote_repositories() const;

    [[nodiscard]] generator<ast::import_module_declaration_node*> imported_modules() const;

    std::expected<void, hkc_error> evaluate_build_guard(datum_namespace const& ctx);

private:
    mutable std::mutex _mutex;

    hk::repository* _parent = nullptr;

    /** The name of the module.
     *
     * The name of the module could be different types:
     *  0. The prologue has not been scanned or there was an error.
     *  1. The fully qualified name of the module.
     *  2. The base name of the program.
     *  3. The base name of the library.
     */
    name_type _name;

    /** The version of the module.
     *
     */
    semantic_version _version;

    /** List of errors found.
     */
    mutable error_list _errors;

    /** If the module is used in the project.
     */
    bool _used = false;

    /** The source of the module.
     *
     * The source of a module:
     *  0. The path to a file,
     *  1. The name of the module that generated this source and the line number.
     */
    source_type _source_filename;

    /** The modules source code.
     *
     * The source code must have 8 nul characters at the end of the text.
     *
     * - Empty when the source code is out-of-date.
     */
    std::string _source_code;

    /** This is the timestamp when the source_code was read from disk.
     *
     * This is used to detect if the file has been modified since it was last
     * parsed.
     */
    std::filesystem::file_time_type _source_code_time = {};

    /** This is the table of line synchronization points.
     *
     * This is used to query where a character is located.
     */
    line_table _lines;

    /** The abstract syntax tree of just the prologue.
     *
     * - Empty when the source code is out-of-data.
     */
    std::unique_ptr<ast::top_node> _prologue_ast;

    /** The abstract syntax tree of the module.
     *
     * - Empty when the source code is out-of-data.
     */
    std::unique_ptr<ast::top_node> _ast;

    /** Reset compilation state when the file has been loaded.
     *
     */
    void reset();

    /** Load the file if it has changed on disk.
     *
     */
    std::expected<bool, std::error_code> load();
};

[[nodiscard]] std::strong_ordering cmp_sources(source const& lhs, source const& rhs) noexcept;

/** Compare the names of the file declaration.
 * 
 * Ordering sequence is:
 *  * Order by kind: program, library, module
 *  * Order by name declared in the prologue
 *  * Order by the path of the repository
 */
[[nodiscard]] std::partial_ordering cmp_names(source const& lhs, source const& rhs) noexcept;

/** Compare the names of the file declaration.
 * 
 * Ordering sequence is:
 *  * Order by kind: program, library, module
 *  * Order by version declared in the prologue
 *  * Order by the path of the repository
 */
[[nodiscard]] std::strong_ordering cmp_versions(source const& lhs, source const& rhs) noexcept;

/** Check if the module passed as the first argument is a child of the second
 * argument.
 *
 * @param child The child module
 * @param parent The parent module.
 * @return If @a child is a sub-module of @a parent. Or if @a child has the same
 *         name as @a parent.
 */
[[nodiscard]] bool is_child_of(source const& child, source const& parent) noexcept;

} // namespace hk
