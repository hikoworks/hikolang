
#pragma once

#include "ast/top_node.hpp"
#include "utility/semantic_version.hpp"
#include "error/error_list.hpp"
#include "tokenizer/line_table.hpp"
#include <gsl/gsl>
#include <expected>
#include <system_error>
#include <filesystem>
#include <memory>
#include <variant>
#include <compare>

namespace hk {

class repository;

class source {
public:
    enum class kind_type {
        unknown,
        module,
        library,
        program
    };

    /** Create a source from a file in the repository.
     * 
     * @param path The cannonical path to the source-code file.
     */
    source(repository &parent, std::filesystem::path path);

    /** Create a source that was generated by another module in the repository.
     * 
     * @param generating_module The module that generated the source code.
     * @param lineno The lineno where the source code was generated.
     */
    source(repository &parent, fqname generating_module, size_t lineno);

    /** The code was generated by another module.
     */
    [[nodiscard]] bool is_generated() const noexcept;

    /** The kind of source this is.
     * 
     *  - unknown: The prologue has not been scanned or there was an error.
     *  - module: The source is a module file.
     *  - program: The source code will generate an executable.
     *  - library: The source code will generate an FFI-library.
     */
    [[nodiscard]] kind_type kind() const noexcept;

    /** Path to the source code.
     * 
     * @return Path to the source code, or empty if the code was generated.
     */
    [[nodiscard]] std::filesystem::path const &path() const;

    /** Parse the prologue.
     * 
     * This function will optionally load a fresh copy of source-code from
     * disk, then read the prologue.
     * 
     * @return If prologue of the source file was modified, or an error.
     */
    std::expected<bool, std::error_code> parse_prologue();

    [[nodiscard]] friend std::strong_ordering cmp_sources(source const& lhs, source const& rhs) noexcept
    {
        if (auto r = lhs._source.index() <=> rhs._source.index(); r != std::strong_ordering::equal) {
            return r;
        } else if (lhs._source.index() == 0) {
            return std::get<std::filesystem::path>(lhs._source) <=> std::get<std::filesystem::path>(rhs._source);
        } else {
            return std::get<std::pair<fqname, size_t>>(lhs._source) <=> std::get<std::pair<fqname, size_t>>(rhs._source);      
        }
    }

    [[nodiscard]] friend std::partial_ordering cmp_names(source const& lhs, source const& rhs) noexcept
    {
        if (lhs._name.index() == 0 or rhs._name.index() == 0) {
            return std::partial_ordering::unordered;
        } else if (auto r = lhs._name.index() <=> rhs._name.index(); r != std::strong_ordering::equal) {
            return r;
        } else {
            switch (lhs._name.index()) {
            case 1:
                return std::get<fqname>(lhs._source) <=> std::get<fqname>(rhs._source);
            case 2:
                return std::get<std::string>(lhs._source) <=> std::get<std::string>(rhs._source);
            case 3:
                return std::get<std::string>(lhs._source) <=> std::get<std::string>(rhs._source);
            }
            std::unreachable();
        }
    }

private:
    gsl::not_null<repository *> _parent;

    /** The name of the module.
     * 
     * The name of the module could be different types:
     *  0. The prologue has not been scanned or there was an error.
     *  1. The fully qualified name of the module.
     *  2. The base name of the program.
     *  3. The base name of the library.
     */
    std::variant<std::monostate, fqname, std::string, std::string> _name;

    /** The version of the module.
     * 
     */
    semantic_version _version;


    /** List of errors found.
     */
    mutable error_list _errors;

    /** The source of the module.
     * 
     * The source of a module:
     *  0. The path to a file,
     *  1. The name of the module that generated this source and the line number.
     */
    std::variant<std::filesystem::path, std::pair<fqname, size_t>> _source;

    /** The modules source code.
     * 
     * The source code must have 8 nul characters at the end of the text.
     * 
     * - Empty when the source code is out-of-date.
     */
    std::string _source_code;

    /** This is the timestamp when the source_code was read from disk.
     * 
     * This is used to detect if the file has been modified since it was last
     * parsed.
     */
    std::filesystem::file_time_type _source_code_time = {};

    /** This is the table of line synchronization points.
     * 
     * This is used to query where a character is located.
     */
    line_table _lines;

    /** The abstract syntax tree of just the prologue.
     * 
     * - Empty when the source code is out-of-data.
     */
    std::unique_ptr<ast::top_node> _prologue_ast;

    /** The abstract syntax tree of the module.
     * 
     * - Empty when the source code is out-of-data.
     */
    std::unique_ptr<ast::top_node> _ast;

    /** Reset compilation state when the file has been loaded.
     * 
     */
    void reset();

    /** Load the file if it has changed on disk.
     * 
     */
    std::expected<bool, std::error_code> load();

};

}
